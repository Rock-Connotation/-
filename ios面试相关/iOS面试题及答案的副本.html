<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.8 (461812)"/><meta name="created" content="2020-04-11 04:09:35 +0000"/><meta name="updated" content="2020-04-11 04:09:35 +0000"/><title>iOS面试题及答案的副本</title></head><body><ol style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">设计模式是什么？ 你知道哪些设计模式，并简要叙述？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。</span></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">MVC 和 MVVM 的区别</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). #import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">frame 和 bounds 有什么不同？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property 的本质是什么？</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        @property = ivar + getter + setter;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">属性可以拥有的特质分为四类:</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1.原子性--- nonatomic 特质</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2.读/写权限---readwrite(读写)、readonly (只读)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3.内存管理语义---assign、strong、 weak、unsafe_unretained、copy</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4.方法名---getter=&lt;name&gt; 、setter=&lt;name&gt;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5.不常用的：nonnull,null_resettable,nullable</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). readwrite 是可读可写特性。需要生成getter方法和setter方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么情况使用 weak 关键字，相比 assign 有什么不同？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">IBOutlet连出来的视图属性为什么可以被设置成weak?</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        因为父控件的subViews数组已经对它有一个强引用。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">不同点：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">怎么用 copy 关键字？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 用途：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 2. block 也经常使用 copy 关键字。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 说明：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">浅拷贝和深拷贝的区别？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">系统对象的 copy 与 mutableCopy 方法</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">不管是集合类对象（NSArray、NSDictionary、NSSet ... 之类的对象），还是非集合类对象（NSString, NSNumber ... 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. mutableCopy 返回的是可变对象（mutableObject）。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">一、非集合类对象的copy与mutableCopy</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  对可变对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSString *str = @"hello word!";</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSString *strCopy = [str copy] // 指针复制，strCopy与str的地址一样</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy与str的地址不一样</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSMutableString *mutableStr = [NSMutableString stringWithString: @"hello word!"];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSString *strCopy = [mutableStr copy] // 内容复制</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">二、集合类对象的copy与mutableCopy (同上)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSArray *arr = @[@[@"a", @"b"], @[@"c", @"d"];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSArray *copyArr = [arr copy]; // 指针复制</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSMutableArray *mCopyArr = [arr mutableCopy]; //单层内容复制</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSArray *copyArr = [mutableArr copy]; // 单层内容复制</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSMutableArray *mCopyArr = [mutableArr mutableCopy]; // 单层内容复制</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">【总结一句话】：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">具体步骤：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        1. 需声明该类遵从 NSCopying 协议</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        2. 实现 NSCopying 协议的方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                // 该协议只有一个方法: </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                - (id)copyWithZone:(NSZone *)zone;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">写一个 setter 方法用于完成 @property (nonatomic, retain) NSString </span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">*name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// retain</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)setName:(NSString *)str {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  [str retain];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  [_name release];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  _name = str;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// copy</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)setName:(NSString *)str {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  id t = [str copy];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  [_name release];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  _name = t;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">@synthesize 和 @dynamic 分别有什么作用？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">id 声明的对象有什么特性？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">Objective-C 如何对内存管理的，说说你的看法和解决方法？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">Category（类别）、 Extension（扩展）和继承的区别</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">区别：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. 分类有名字，类扩展没有分类名字，是一种特殊的分类。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3. 继承可以增加，修改或者删除方法，并且可以增加属性。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">我们说的OC是动态运行时语言是什么意思？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">为什么我们常见的delegate属性都用是week而不是retain/strong？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：是为了防止delegate两端产生不必要的循环引用。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property (nonatomic, weak) id&lt;UITableViewDelegate&gt; delegate;</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么时候用delete，什么时候用Notification？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Delegate(委托模式)：1对1的反向消息通知功能。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 KVO 和 KVC？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        举例说明：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        </span><a shape="rect" style="font-size: 12px; font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;" href="http://stu.name/" target="_blank">stu.name</a><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> = @"张三" // 点语法给属性赋值</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        [stu setValue:@"张三" forKey:@"name"]; // 通过字符串使用KVC方式给属性赋值</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        stu1.nameLabel.text = @"张三";</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        [stu1 setValue:@"张三" forKey:@"nameLabel.text"]; // 跨层赋值</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   // 通过下方方法为属性添加KVO观察</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   - (void)addObserver:(NSObject *)observer</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                     forKeyPath:(NSString *)keyPath</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                     options:(NSKeyValueObservingOptions)options</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                     context:(nullable void *)context;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   // 当被观察的属性发送变化时，会自动触发下方方法                   </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   - (void)observeValueForKeyPath:(NSString *)keyPath</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                              ofObject:(id)object</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                                  change:(NSDictionary *)change</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                                 context:(void *)context{}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">KVC的底层实现？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">当一个对象调用setValue方法时，方法内部会做以下操作：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">KVO的底层实现？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">KVO基于runtime机制实现。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">ViewController生命周期</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">按照执行顺序排列：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. initWithCoder：通过nib文件初始化时触发。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3. loadView：开始加载视图控制器自带的view。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4. viewDidLoad：视图控制器的view被加载完成。  </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5. viewWillAppear：视图控制器的view将要显示在window上。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6. updateViewConstraints：视图控制器的view开始更新AutoLayout约束。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">7. viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">8. viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">9. viewDidAppear：视图控制器的view已经展示到window上。 </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">10. viewWillDisappear：视图控制器的view将要从window上消失。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">11. viewDidDisappear：视图控制器的view已经从window上消失。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">方法和选择器有何不同？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">selector是一个方法的名字，方法是一个组合体，包含了名字和实现。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">你是否接触过OC中的反射机制？简单聊一下概念和使用</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). class反射</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        通过类名的字符串形式实例化对象。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                Class class = NSClassFromString(@"student"); </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                Student *stu = [[class alloc] init];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        将类名变为字符串。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                Class class =[Student class];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                NSString *className = NSStringFromClass(class);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). SEL的反射</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        通过方法的字符串形式实例化方法。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                SEL selector = NSSelectorFromString(@"setName");  </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                [stu performSelector:selector withObject:@"Mike"];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        将方法变成字符串。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                NSStringFromSelector(@selector*(setName:));</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">调用方法有两种方式：</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 直接通过方法名来调用。[person show];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];</span><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  </span></div><div><br clear="none"/></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何对iOS设备进行性能测试？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答： Profile-&gt; Instruments -&gt;Time Profiler</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">开发项目时你是怎么检查内存泄露？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 静态分析 analyze。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). instruments工具里面有个leak可以动态分析。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是懒加载？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">类变量的 @public，@protected，@private，@package 声明各有什么含义？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@public 任何地方都能访问;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@protected 该类和子类中访问,是默认的;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@private 只能在本类中访问;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@package 本包内使用,跨包不可以。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是谓词？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">NSPredicate *predicate = [NSPredicate predicateWithFormat:@"age&lt;%d",30];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">NSArray *array = [persons filteredArrayUsingPredicate:predicate];</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">isa指针问题</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何访问并修改一个类的私有属性？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 一种是通过KVC获取。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 通过runtime访问并修改私有属性。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">一个objc对象的isa的指针指向什么？有什么作用？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：指向他的类对象,从而可以找到对象上的方法。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">下面的代码输出什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@implementation Son : Father</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (id)init {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   if (self = [super init]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       NSLog(@"%@", NSStringFromClass([self class])); // Son</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       NSLog(@"%@", NSStringFromClass([super class])); // Son</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   return self;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@end</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 解析：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">self 是类的隐藏参数，指向当前调用方法的这个类的实例。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">写一个完整的代理，包括声明、实现</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 创建</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@protocol MyDelagate</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@required</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">-(void)eat:(NSString *)foodName; </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@optional</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">-(void)run;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@end</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//  声明 .h</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@interface person: NSObject&lt;MyDelagate&gt;</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@end</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//  实现 .m</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@implementation person</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)eat:(NSString *)foodName { </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   NSLog(@"吃:%@!", foodName);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">} </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)run {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   NSLog(@"run!");</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@end</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">isKindOfClass、isMemberOfClass、selector作用分别是什么</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">isMemberOfClass：某个对象确切属于某个类型。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">selector：通过方法名，获取在内存中的函数的入口地址。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">delegate 和 notification 的区别</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). notification通过维护一个array，实现一对多消息的转发。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是block？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">闭包（block）：闭包就是获取其它函数局部变量的匿名函数。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">block反向传值</span></div></li></ol><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 12px; line-height: 24px;-en-paragraph:true;">在控制器间传值可以使用代理或者block，使用block相对来说简洁。</span></div></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 12px; line-height: 24px;-en-paragraph:true;">在前一个控制器的touchesBegan:方法内实现如下代码。</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px;">  // OneViewController.m</span></div><div><span style="font-size: 12px;">  TwoViewController *twoVC = [[TwoViewController alloc] init];</span></div><div><span style="font-size: 12px;">  twoVC.valueBlcok = ^(NSString *str) {</span></div><div><span style="font-size: 12px;">        NSLog(@"OneViewController拿到值：%@", str); </span></div><div><span style="font-size: 12px;">  };</span></div><div><span style="font-size: 12px;">  [self presentViewController:twoVC animated:YES completion:nil];</span></div><div><br clear="none"/></div><div><span style="font-size: 12px;">  // TwoViewController.h   （在.h文件中声明一个block属性）</span></div><div><span style="font-size: 12px;">  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);</span></div><div><br clear="none"/></div><div><span style="font-size: 12px;">  // TwoViewController.m   （在.m文件中实现方法）</span></div><div><span style="font-size: 12px;">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {</span></div><div><span style="font-size: 12px;">        // 传值:调用block</span></div><div><span style="font-size: 12px;">        if (_valueBlcok) {</span></div><div><span style="font-size: 12px;">                _valueBlcok(@"123456");</span></div><div><span style="font-size: 12px;">        }</span></div><div><span style="font-size: 12px;">}</span></div><div><br clear="none"/></div></div></div><ol start="47" style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">block的注意点</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        __weak typeof(self) weakSelf = self; </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        __strong typeof(self) strongSelf = weakSelf;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">BAD_ACCESS在什么情况下出现？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">lldb（gdb）常用的控制台调试命令？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). p 输出基本类型。是打印命令，需要指定类型。是print的简写</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        p (int)[[[self view] subviews] count]</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). po 打印对象，会调用对象description方法。是print-object的简写</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        po [self view]</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). br l：是breakpoint list的简写</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">你一般是怎么用Instruments的？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Instruments里面工具很多，常用：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). Time Profiler: 性能分析</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). Allocations：用来检查内存，写算法的那批人也用这个来检查。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). Leaks：检查内存，看是否有内存泄露。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">iOS中常用的数据存储方式有哪些？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">数据存储有四种方案：NSUserDefault、KeyChain、file、DB。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        其中File有三种方式：plist、Archive（归档）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        DB包括：SQLite、FMDB、CoreData</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">iOS的沙盒目录结构是怎样的？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">沙盒结构：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). Library：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                Caches：存放体积大又不需要备份的数据。(常用的缓存路径)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                Preference：设置目录，iCloud会备份设置信息。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">iOS多线程技术有哪几种方式？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：pthread、NSThread、GCD、NSOperation</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">GCD 与 NSOperation 的区别：</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">GCD 和 NSOperation 都是用于实现多线程：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">写出使用GCD方式从子线程回到主线程的方法代码</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：dispatch_sync(dispatch_get_main_queue(), ^{ });</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 创建队列组</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_group_t group = dispatch_group_create();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 获取全局并发队列</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_group_async(group, queue, ^{ /*加载图片1 */ });</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_group_async(group, queue, ^{ /*加载图片2 */ });</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 当并发队列组中的任务执行完毕后才会执行这里的代码</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_group_notify(group, dispatch_get_main_queue(), ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        // 合并图片</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">dispatch_barrier_async（栅栏函数）的作用是什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">作用：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        2.避免数据竞争</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 1.创建并发队列</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 2.向队列中添加任务</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_async(queue, ^{  // 1.2是并行的</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"任务1, %@",[NSThread currentThread]);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_async(queue, ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"任务2, %@",[NSThread currentThread]);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_barrier_async(queue, ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"任务 barrier, %@", [NSThread currentThread]);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_async(queue, ^{   // 这两个是同时执行的</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"任务3, %@",[NSThread currentThread]);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">dispatch_async(queue, ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"任务4, %@",[NSThread currentThread]);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">});</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">以下代码运行结果如何？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)viewDidLoad {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    [super viewDidLoad];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"1");</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    dispatch_sync(dispatch_get_main_queue(), ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        NSLog(@"2");</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    });</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    NSLog(@"3");</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 只输出：1。（主线程死锁）</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 RunLoop</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int main(int argc, char * argv[]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        @autoreleasepool {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 Runtime</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">Runtime实现的机制是什么，怎么用，一般用于干嘛？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). Runtime 运行时机制，它是一套C语言库。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        比如：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                类转成了 Runtime 库里面的结构体等数据类型，</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                方法转成了 Runtime 库里面的C语言函数，</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        // OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        // [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));    </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">有了Runtime库，能做什么事情呢？</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> Runtime库里面包含了跟类、成员变量、方法相关的API。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 比如：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    （1）获取类里面的所有成员变量。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    （2）为类动态添加成员变量。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    （3）动态改变类的方法实现。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    （4）为类动态添加新的方法等。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> 因此，有了Runtime，想怎么改就怎么改。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 Method Swizzle（黑魔法），什么情况下会使用？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6). 我们可以利用 class_replaceMethod 来修改类。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">8). 归根结底，都是偷换了selector的IMP。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 TCP / UDP ?</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">TCP：传输控制协议。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UDP：用户数据协议。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">通信底层原理（OSI七层模型）</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">OSI采用了分层的结构化技术，共分七层：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">介绍一下XMPP？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">XMPP是一种以XML为基础的开放式实时通信协议。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 创建线程的方法</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [self performSelectorInBackground:nil withObject:nil];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- dispatch_async(dispatch_get_global_queue(0, 0), ^{});</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [[NSOperationQueue new] addOperation:nil];</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 主线程中执行代码的方法</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- dispatch_async(dispatch_get_main_queue(), ^{});</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- [[NSOperationQueue mainQueue] addOperation:nil];</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">tableView的重用机制？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">用伪代码写一个线程安全的单例模式</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">static id _instance;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">+ (id)allocWithZone:(struct _NSZone *)zone {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   static dispatch_once_t onceToken;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   dispatch_once(&amp;onceToken, ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       _instance = [super allocWithZone:zone];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   });</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   return _instance;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">+ (instancetype)sharedData {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   static dispatch_once_t onceToken;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   dispatch_once(&amp;onceToken, ^{</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">       _instance = [[self alloc] init];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   });</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   return _instance;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (id)copyWithZone:(NSZone *)zone {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   return _instance;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何实现视图的变形?</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：通过修改view的 transform 属性即可。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">字符串常用方法：</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">NSString *str = @"abc*123";</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">NSArray *arr = [str componentsSeparatedByString:@"*"]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@"abc", @"123"];</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何高性能的给 UIImageView 加个圆角?</span></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">不好的解决方案：使用下面的方式会</span><span style="text-indent: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响</span><span style="text-indent: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">，会有卡顿的现象出现。</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">self.view.layer.cornerRadius = 5.0f;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">self.view.layer.masksToBounds = YES;</span></div><div><br clear="none"/></div></div></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">正确的解决方案：使用绘图技术</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (UIImage *)circleImage {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // NO代表透明</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 获得上下文</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 添加一个圆</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    CGContextAddEllipseInRect(ctx, rect);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 裁剪</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    CGContextClip(ctx);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 将图片画上去</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    [self drawInRect:rect];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 关闭上下文</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    UIGraphicsEndImageContext();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return image;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">imageView.center = CGPointMake(200, 300);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UIImage *anotherImage = [UIImage imageNamed:@"image"];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                       cornerRadius:50] addClip];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">[anotherImage drawInRect:imageView.bounds];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">imageView.image = UIGraphicsGetImageFromCurrentImageContext();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">UIGraphicsEndImageContext();</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">[self.view addSubview:imageView];</span></div><div><br clear="none"/></div></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">你是怎么封装一个view的</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1）. 可以通过纯代码或者xib的方式来封装子控件</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2）. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值</span></div><div><br clear="none"/></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/**</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *  纯代码初始化控件时一定会走这个方法</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (instancetype)initWithFrame:(CGRect)frame {</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    if(self = [super initWithFrame:frame]) {</span></div><div><span style="font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        [self setupUI];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return self;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/**</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *  通过xib初始化控件时一定会走这个方法</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (id)initWithCoder:(NSCoder *)aDecoder {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    if(self = [super initWithCoder:aDecoder]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        [self setupUI];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return self;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (void)setupUI {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    // 初始化代码</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">HTTP协议中 POST 方法和 GET 方法有那些区别?</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. GET用于向服务器请求数据，POST用于提交数据</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3. GET请求的URL有长度限制，POST请求不会有长度限制</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">请简单的介绍下APNS发送系统消息的机制</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">APNS的原理：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        2). 应用程序接收到设备令牌并发送给自己的后台服务器</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        3). 服务器把要推送的内容和设备发送给APNS</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示</span></div><div><br clear="none"/></div></div></li></ol><h1 style="font-size: 28px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 28px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">第三方框架</span></h1><ol style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">AFNetworking 底层原理分析</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        (AFJSONRequestSerializer).使用不多。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">7). AFJSONResponseSerializer; JSON解析器,默认的解析器.</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">制数据.对服务器返回的数据不做任何处理.</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">9). AFXMLParserResponseSerializer; XML解析器;</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">描述下SDWebImage里面给UIImageView加载图片的逻辑</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">加载图片的过程大致如下：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        4.下载后的图片会加入缓存中，并写入磁盘中</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">SDWebImage原理：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">调用类别的方法：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        1. 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        2. 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        3. 从网络上获取，使用，缓存到内存，缓存到沙盒。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">友盟统计接口统计的所有功能</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">APP启动速度，APP停留页面时间等</span></div><div><br clear="none"/></div></div></li></ol><h1 style="font-size: 28px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 28px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">算法</span></h1><ol style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">不用中间变量,用两种方法交换A和B的值</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 1.中间变量</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void swap(int a, int b) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   int temp = a;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   a = b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   b = temp;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 2.加法</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void swap(int a, int b) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   a = a + b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   b = a - b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   a = a - b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 3.异或（相同为0，不同为1. 可以理解为不进位加法）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void swap(int a, int b) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   a = a ^ b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   b = a ^ b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">   a = a ^ b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">求最大公约数</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/** 1.直接遍历法 */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int maxCommonDivisor(int a, int b) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    int max = 0;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    for (int i = 1; i &lt;=b; i++) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        if (a % i == 0 &amp;&amp; b % i == 0) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            max = i;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return max;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/** 2.辗转相除法 */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int maxCommonDivisor(int a, int b) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    int r;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    while(a % b &gt; 0) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        r = a % b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        a = b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        b = r;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return b;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 扩展：最小公倍数 = (a * b)/最大公约数</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">模拟栈操作</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> /**</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *  栈是一种数据结构，特点：先进后出</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *  练习：使用全局变量模拟栈的操作</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">#include &lt;stdio.h&gt;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">#include &lt;stdbool.h&gt;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">#include &lt;assert.h&gt;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">static int data[1024];//栈最多能保存1024个数据</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">static int count = 0;//目前已经放了多少个数(相当于栈顶位置)</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//数据入栈 push</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void push(int x){</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        assert(!full());//防止数组越界</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        data[count++] = x;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//数据出栈 pop</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int pop(){</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        assert(!empty());</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        return data[--count];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//查看栈顶元素 top</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int top(){</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        assert(!empty());</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        return data[count-1];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//查询栈满 full</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">bool full() {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        if(count &gt;= 1024) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        return 1;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">     return 0; </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//查询栈空 empty</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">bool empty() {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        if(count &lt;= 0) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                return 1;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return 0;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int main(){</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    //入栈</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    for (int i = 1; i &lt;= 10; i++) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        push(i);</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">  </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    //出栈</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    while(!empty()){</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        printf("%d ", top()); //栈顶元素</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        pop(); //出栈</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    printf("\n");</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return 0;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">排序算法</span></div><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</span></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">都将数组分为已排序部分和未排序部分。</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1. 选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2. 冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3. 插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</span></div><div><br clear="none"/></div></div></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">选择排序</span></div></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/** </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      【选择排序】：最值出现在起始端</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第1趟：在n个数中找到最小(大)数与第一个数交换位置</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      重复这样的操作...依次与第三个、第四个...数交换位置</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第n-1趟，最终可实现数据的升序（降序）排列。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void selectSort(int *arr, int length) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    for (int i = 0; i &lt; length - 1; i++) { //趟数</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        for (int j = i + 1; j &lt; length; j++) { //比较次数</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            if (arr[i] &gt; arr[j]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                int temp = arr[i];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                arr[i] = arr[j];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                arr[j] = temp;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div><div style="list-style-type: disc;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">冒泡排序</span></div></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/** </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *       ……   ……</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置     </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">void bublleSort(int *arr, int length) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    for(int i = 0; i &lt; length - 1; i++) { //趟数</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        for(int j = 0; j &lt; length - i - 1; j++) { //比较次数</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            if(arr[j] &gt; arr[j+1]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                int temp = arr[j];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                arr[j] = arr[j+1];</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">                arr[j+1] = temp;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        } </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">折半查找（二分查找）</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">/**</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      折半查找：优化查找时间（不用遍历全部数据）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *      折半查找的原理：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *   1&gt; 数组必须是有序的</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *   2&gt; 必须已知min和max（知道范围）</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *   3&gt; 动态计算mid的值，取出mid对应的值进行比较</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *   4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *   5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> *</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;"> */ </span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int findKey(int *arr, int length, int key) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    int min = 0, max = length - 1, mid;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    while (min &lt;= max) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        mid = (min + max) / 2; //计算中间值</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        if (key &gt; arr[mid]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            min = mid + 1;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        } else if (key &lt; arr[mid]) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            max = mid - 1;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        } else {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">            return mid;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">        }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    return -1;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div><br clear="none"/></div></div></li></ol><div style="text-indent: 0px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">编码格式（优化细节）</span></div><ol style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">在 Objective-C 中，enum 建议使用 </span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">NS_ENUM</span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;"> 和 </span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">NS_OPTIONS</span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;"> 宏来定义枚举类型。</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//定义一个枚举(比较严密)</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">typedef NS_ENUM(NSInteger, BRUserGender) {</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    BRUserGenderUnknown,        // 未知</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    BRUserGenderMale,           // 男性</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    BRUserGenderFemale,         // 女性</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">    BRUserGenderNeuter          // 无性</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">};</span></div><div><br clear="none"/></div></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@interface BRUser : NSObject&lt;NSCopying&gt;</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property (nonatomic, readonly, copy) NSString *name;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property (nonatomic, readonly, assign) NSUInteger age;</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@property (nonatomic, readonly, assign) BRUserGender gender;</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(BRUserGender)gender;</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">@end</span></div><div><br clear="none"/></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//说明：</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//既然该类中已经有一个“初始化方法” ，用于设置 name、age 和 gender 的初始值: 那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">//属性的参数应该按照下面的顺序排列： （原子性，读写，内存管理）</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">int -&gt; NSInteger</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">unsigned -&gt; NSUInteger</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">float -&gt; CGFloat</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">动画时间 -&gt; NSTimeInterval</span></div><div><br clear="none"/></div></div></li></ol><h1 style="font-size: 28px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 28px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">其它知识点</span></h1><ol style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">HomeKit</span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">，是苹果2014年发布的智能家居平台。</span></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 OpenGL、Quartz 2D？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">ffmpeg框架：</span><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;-en-paragraph:true;">ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。</span></div></li></ol><ol start="4" style="padding-left: 40px; font-size: 15px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">谈谈 UITableView 的优化</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">1). 正确的复用cell。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">2). 设计统一规格的Cell</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">5). 减少子视图的层级关系</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">6). 尽量使所有的视图不透明化以及做切圆操作。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">8). 使用调试工具分析问题。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">如何实行cell的动态的行高</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">设置预估行高 tableView.estimatedRowHeight = 200。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。 </span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">说说你对 block 的理解</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">说说你对 runtime 的理解</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是野指针、空指针？</span></div><div style=" white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">野指针：不知道指向了哪里的指针叫野指针。即指针指向不确定，指针存的地址是一个垃圾值，未初始化。</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。</span></div><div><br clear="none"/></div></div></li><li style="list-style-type: decimal;"><div style="text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; font-size: 15px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 24px;-en-paragraph:true;">什么是 OOA / OOD / OOP ?</span></div><div style="white-space: pre-wrap; overflow-wrap: break-word;"><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">OOA（Object Oriented Analysis）   --面向对象分析</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">OOD（Object Oriented Design）     --面向对象设计</span></div><div><span style="font-size: 12px; color: rgb(0, 0, 0); font-family: 微软雅黑, 宋体, Arial; font-variant-caps: normal; font-variant-ligatures: normal;">OOP（Object Oriented Programming）--面向对象编程</span></div></div></li></ol><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="color: rgb(255, 38, 0);">其它面试题：</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">1：浅析NSSet与NSArray之间的区别</span></div><div><br clear="none"/></div><div>首先，NSArray存的数据是有序排列的，并且数组中的元素可以一样，而NSSet存的数据是无序的，而且元素是不能一样的，也就是在NSSet中的元素是唯一的。</div><div><br clear="none"/></div><div>第二，NSSet还是有它自己的优势的，NSSet的底层是用hash思想来实现的，所有就保证了存储对象的唯一性（上边提到过），这样做的话也造就了它的查询速度快，但是不能把某某对象存在第几个元素后面之类的有关脚标的操作，至于为什么查询速度快，我们可以这么想，NSSet是通过hash值来找到某一元素的存储位置，速度当然快，而NSArray呢？它是通过遍历数组中的所有元素来找到对应的值的，效率肯定会大大降低了。</div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">2：RunTime面试题及答案</span></div><div><br clear="none"/></div><div>问题: objc在向一个对象发送消息时, 发生了什么?</div><div>1.根据对象的isa指针找到类对象id, 在查询类对象里面的methodLists方法函数列表</div><div>2.如果没有在好到, 在沿着superClass, 寻找父类，再在父类methodLists方法列表里面查询</div><div>3.最终找到SEL, 根据id和SEL确认IMP(指针函数), 在发送消息.</div><div><br clear="none"/></div><div>问题: 什么时候会报unrecognized selector错误? iOS有哪些机制来避免走到这一步?</div><div>1.当发送消息的时候, 我们会根据类里面的methodLists列表去查询我们要动用的SEL, 当查询不到的时候, 我们会一直沿着父类查询</div><div>2.当最终查询不到的时候我们会报unrecognized selector错误, 当系统查询不到方法的时候, 会调用+(BOOL)resolveInstanceMethod:(SEL)sel动态解释的方法来给我一次机会来添加, 调用不到的方法.</div><div>3.或者我们可以再次使用-(id)forwardingTargetForSelector:(SEL)aSelector重定向的方法来告诉系统，该调用什么方法，一来保证不会崩溃.</div><div><br clear="none"/></div><div>问题: 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量? 为什么?</div><div>1.不能向编译后得到的类增加实例变量.</div><div>2.能向运行时创建的类中添加实例变量.</div><div>解释:</div><div>1. 编译后的类已经注册在runtime中,类结构体中的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定，runtime会调用class_setvarlayout或class_setWeaklvarLayout来处理strong``weak引用.所以不能向存在的类中添加实例变量.</div><div>2. 运行时创建的类是可以添加实例变量，调用class_addIvar函数. 但是的在调用objc_allocateClassPair之后，objc_registerClassPair之前,原因同上.</div><div><br clear="none"/></div><div>问题: runtime如何实现weak变量的自动置nil?</div><div>1.runtime对注册的类, 会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc.</div><div>2.假如weak指向的对象内存地址是A，那么就会以A为键， 在这个weak表中搜索，找到所有以A为键的weak对象，从而设置为nil.</div><div><br clear="none"/></div><div>问题: 给类添加一个属性后，在类结构体里哪些元素会发生变化</div><div>1.instance_size ：实例的内存大小.</div><div>2.objc_ivar_list *ivars : 属性列表.</div><div><br clear="none"/></div><div>---------------------------------------------------------------------------</div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">3:weak的实现原理</span></div><div><br clear="none"/></div><div>很少有人知道weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址数组。更多人的人只是知道weak是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为nil。通常用于解决循环引用问题。但现在单知道这些已经不足以应对面试了，好多公司会问weak的原理。weak的原理是什么呢？下面就分析一下weak的工作原理（只是自己对这个问题好奇，学习过程中的笔记，希望对读者也有所帮助）。</div><div><br clear="none"/></div><div>weak 实现原理的概括</div><div><br clear="none"/></div><div>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</div><div><br clear="none"/></div><div>weak 的实现原理可以概括一下三步：</div><div><br clear="none"/></div><div>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。</div><div><br clear="none"/></div><div>2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</div><div><br clear="none"/></div><div>3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">4:MVVM</span></div><div><br clear="none"/></div><div>MVVM的诞生</div><div><br clear="none"/></div><div>就像我们之前分析MVC是如何合理分配工作的一样，我们需要数据所以有了M，我们需要界面所以有了V，而我们需要找一个地方把M赋值给V来显示，所以有了C，然而我们忽略了一个很重要的操作：数据解析。在MVC出生的年代，手机APP的数据往往都比较简单，没有现在那么复杂，所以那时的数据解析很可能一步就解决了，所以既然有这样一个问题要处理，而面向对象的思想就是用类和对象来解决问题，显然V和M早就被定义死了，它们都不应该处理“解析数据”的问题，理所应当的，“解析数据”这个问题就交给C来完成了。而现在的手机App功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。如果我们继续按照MVC的设计思路，将数据解析的部分放到了Controller里面，那么Controller就将变得相当臃肿。还有相当重要的一点：Controller被设计出来并不是处理数据解析的。1、管理自己的生命周期；2、处理Controller之间的跳转；3、实现Controller容器。这里面根本没有“数据解析”这一项，所以显然，数据解析也不应该由Controller来完成。那么我们的MVC中，M、V、C都不应该处理数据解析，那么由谁来呢？这个问题实际上在面向对象的时候相当好回答：既然目前没有类能够处理这个问题，那么就创建一个新的类出来解决不就好了？所以我们聪明的开发者们就专门为数据解析创建出了一个新的类：ViewModel。这就是MVVM的诞生。</div><div><br clear="none"/></div><div>如何实现MVVM</div><div><br clear="none"/></div><div>搞清楚了MVVM为什么会出现，将对于你理解如何实现MVVM有极大的帮助。在我们开始着手实现MVVM之前，我先简单提一下之前遗留的一个问题：为什么MVVM这个名字里面，没有Controller的出现（为什么不叫MVCVM，C去哪了）。本来这个问题应该在实现后再来解释，但是我们这里是教学，为了让大家更好的明白我们接下来的思想，所以这里要提前解释一下这个结论：Controller的存在感被完全的降低了。我们在待会实现MVVM的时候你就能体会到了，这里请先把这个结论印在脑海当中：Controller的存在感被完全的降低了、Controller的存在感被完全的降低了、Controller的存在感被完全的降低了。</div><div>好的，我们终于要开始着手实现MVVM了。如果你已经搞懂了MVC，那么用MVVM实现一个相同的功能将会变得非常简单。你只需要记住两点：1、Controller的存在感被完全的降低了；2、VM的出现就是Controller存在感降低的原因。</div><div><br clear="none"/></div><div>Controller存在感降低的原因</div><div><br clear="none"/></div><div>在MVVM中，Controller不再像MVC那样直接持有Model了。想象Controller是一个Boss，数据是一堆文件（Model），如果现在是MVC，那么数据解析（比如整理文件）需要由Boss亲自完成，然而实际上Boss需要的仅仅是整理好的文件而不是那一堆乱七八糟的整理前的文件。所以Boss招聘了一个秘书，现在Boss就不再需要管理原始数据（整理之前的文件）了，他只需要去找秘书：你帮我把文件整理好后给我。那么这个秘书就首先去拿到文件（原始数据），然后进行整理（数据解析），接下来把整理的结果给Boss。所以秘书就是VM了，并且Controller（Boss）现在只需要直接持有VM而不需要再持有M了。如果再进一步理解C、VM、M之间的关系：因为Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“如何解析Model”给封装起来了，C甚至根本就不需要知道M的存在就能把工作做好，前提它需要持有一个VM。那么我们MVVM中的持有关系就是：C持有VM，VM持有M。这里有一个比较争议的地方：C该不该持有M。我的答案是不该。为什么呢，因为C持有M没有任何意义。就算C直接拿到了M的数据，它还是要去让VM进行数据解析，而数据解析就需要M，那么直接让VM持有M而C直接持有VM就足够了。最后再分享一个我在实现MVVM中的一个技巧，也谈不上是技巧吧，算是一种必要的思想：一旦在实现Controller的过程中遇到任何跟Model（或者数据）相关的问题，就找VM要答案。</div><div><br clear="none"/></div><div><br clear="none"/></div><div><span style="font-weight: bold;">5:iOS开发中解决UIScrollView滚动时NSTimer失效的问题</span></div><div><br clear="none"/></div><div>我不知道大家在使用NSTimer的时候有没有发现如果我们滑动ScrollView，NSTimer就会失效。我曾经遇到过这样的问题，但需求是即使滑动scrollView，NSTimer也不能失效，于是就好好地研究了下这个问题。最终发现是NSTimer选择的一个模式的问题。</div><div><br clear="none"/></div><div>代码：</div><div><br clear="none"/></div><div><br clear="none"/></div><div>[[NSRunLoopcurrentRunLoop] addTimer:self.timerforMode:NSDefaultRunLoopMode];</div><div><br clear="none"/></div><div>我们将timer添加到当前的主线程中，并且选择NSDefaultRunLoopMode这个默认的模式。在选择这个默认的模式之后，如果我们不与UI进行交互那么NSTimer是有效的，如果我们与UI进行交互那么主线程runloop就会转到UITrackingRunLoopMode模式下，不能处理定时器，从而定时器失效。</div><div>让定时器不失效的方式有两种：1.改变runloop的模式（NSRunLoopCommonModes），无论用户是否与UI进行交互主线程的runloop都能处理定时器。2.开启一个新的线程，让定时器在新的线程中进行定义，这时定时器就会被子线程中的runloop处理。</div><div><br clear="none"/></div><div>代码：</div><div><br clear="none"/></div><div>改变runloop的模式：</div><div><br clear="none"/></div><div><br clear="none"/></div><div> self.timer = [NSTimertimerWithTimeInterval:1.0target:selfselector:@selector(updateTimer)userInfo:nilrepeats:YES];</div><div><br clear="none"/></div><div>    </div><div><br clear="none"/></div><div>    // 添加到运行循环  NSRunLoopCommonModes:占位模式  主线程</div><div><br clear="none"/></div><div>    [[NSRunLoopcurrentRunLoop] addTimer:self.timerforMode:NSRunLoopCommonModes]; // 如果不改变Mode模式在滑动屏幕的时候定时器就不起作用了</div><div><br clear="none"/></div><div><br clear="none"/></div><div>在子线程中定义定时器：</div><div><br clear="none"/></div><div><br clear="none"/></div><div> [NSThreaddetachNewThreadSelector:@selector(bannerStart)toTarget:selfwithObject:nil];</div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div>// 在子线程中定义定时器</div><div><br clear="none"/></div><div>- (void)bannerStart{</div><div><br clear="none"/></div><div>    self.timer = [NSTimerscheduledTimerWithTimeInterval:1target:selfselector:@selector(updateTimer)userInfo:nilrepeats:YES];</div><div><br clear="none"/></div><div>    [[NSRunLoopcurrentRunLoop] addTimer:self.timerforMode:NSDefaultRunLoopMode];</div><div><br clear="none"/></div><div>    [[NSRunLoopcurrentRunLoop] run];</div><div><br clear="none"/></div><div>}</div><div><br clear="none"/></div><div><br clear="none"/></div><div>- (void)updateTimer</div><div><br clear="none"/></div><div>{</div><div><br clear="none"/></div><div>    NSLog(@"当前线程：%@",[NSThread currentThread]);</div><div><br clear="none"/></div><div>    NSLog(@"启动RunLoop后--%@",[NSRunLoop currentRunLoop].currentMode);</div><div><br clear="none"/></div><div>    NSLog(@"currentRunLoop:%@",[NSRunLoop currentRunLoop]);</div><div><br clear="none"/></div><div>    dispatch_async(dispatch_get_main_queue(), ^{</div><div><br clear="none"/></div><div>        self.count ++;</div><div><br clear="none"/></div><div>        NSString *timerText = [NSString stringWithFormat:@"计时器:%ld",self.count];</div><div><br clear="none"/></div><div>        self.timerLabel.text = timerText;</div><div><br clear="none"/></div><div>    });</div><div><br clear="none"/></div><div>}</div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div></body></html>